// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'theme_config.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

ThemeConfig _$ThemeConfigFromJson(Map<String, dynamic> json) {
  return _ThemeConfig.fromJson(json);
}

/// @nodoc
mixin _$ThemeConfig {
  PandoraTheme get pandoraTheme => throw _privateConstructorUsedError;
  @JsonKey(fromJson: _themeModeFromJson, toJson: _themeModeToJson)
  ThemeMode get themeMode => throw _privateConstructorUsedError;
  AccessibilityLevel get accessibilityLevel =>
      throw _privateConstructorUsedError;
  ContrastLevel get contrastLevel => throw _privateConstructorUsedError;
  SizeClass get sizeClass => throw _privateConstructorUsedError;
  bool get enableAnimations => throw _privateConstructorUsedError;
  bool get enableHapticFeedback => throw _privateConstructorUsedError;
  bool get enableSoundEffects => throw _privateConstructorUsedError;
  double get animationSpeed => throw _privateConstructorUsedError;
  double get textScaleFactor => throw _privateConstructorUsedError;
  double get iconScaleFactor => throw _privateConstructorUsedError;
  double get baseFontSize => throw _privateConstructorUsedError;
  double get lineHeight => throw _privateConstructorUsedError;
  double get spacingUnit => throw _privateConstructorUsedError;
  double get borderRadius => throw _privateConstructorUsedError;
  double get borderWidth => throw _privateConstructorUsedError;
  double get elevation => throw _privateConstructorUsedError;
  double get opacity => throw _privateConstructorUsedError;

  /// Serializes this ThemeConfig to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of ThemeConfig
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ThemeConfigCopyWith<ThemeConfig> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ThemeConfigCopyWith<$Res> {
  factory $ThemeConfigCopyWith(
          ThemeConfig value, $Res Function(ThemeConfig) then) =
      _$ThemeConfigCopyWithImpl<$Res, ThemeConfig>;
  @useResult
  $Res call(
      {PandoraTheme pandoraTheme,
      @JsonKey(fromJson: _themeModeFromJson, toJson: _themeModeToJson)
      ThemeMode themeMode,
      AccessibilityLevel accessibilityLevel,
      ContrastLevel contrastLevel,
      SizeClass sizeClass,
      bool enableAnimations,
      bool enableHapticFeedback,
      bool enableSoundEffects,
      double animationSpeed,
      double textScaleFactor,
      double iconScaleFactor,
      double baseFontSize,
      double lineHeight,
      double spacingUnit,
      double borderRadius,
      double borderWidth,
      double elevation,
      double opacity});

  $PandoraThemeCopyWith<$Res> get pandoraTheme;
  $AccessibilityLevelCopyWith<$Res> get accessibilityLevel;
  $ContrastLevelCopyWith<$Res> get contrastLevel;
  $SizeClassCopyWith<$Res> get sizeClass;
}

/// @nodoc
class _$ThemeConfigCopyWithImpl<$Res, $Val extends ThemeConfig>
    implements $ThemeConfigCopyWith<$Res> {
  _$ThemeConfigCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ThemeConfig
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? pandoraTheme = null,
    Object? themeMode = null,
    Object? accessibilityLevel = null,
    Object? contrastLevel = null,
    Object? sizeClass = null,
    Object? enableAnimations = null,
    Object? enableHapticFeedback = null,
    Object? enableSoundEffects = null,
    Object? animationSpeed = null,
    Object? textScaleFactor = null,
    Object? iconScaleFactor = null,
    Object? baseFontSize = null,
    Object? lineHeight = null,
    Object? spacingUnit = null,
    Object? borderRadius = null,
    Object? borderWidth = null,
    Object? elevation = null,
    Object? opacity = null,
  }) {
    return _then(_value.copyWith(
      pandoraTheme: null == pandoraTheme
          ? _value.pandoraTheme
          : pandoraTheme // ignore: cast_nullable_to_non_nullable
              as PandoraTheme,
      themeMode: null == themeMode
          ? _value.themeMode
          : themeMode // ignore: cast_nullable_to_non_nullable
              as ThemeMode,
      accessibilityLevel: null == accessibilityLevel
          ? _value.accessibilityLevel
          : accessibilityLevel // ignore: cast_nullable_to_non_nullable
              as AccessibilityLevel,
      contrastLevel: null == contrastLevel
          ? _value.contrastLevel
          : contrastLevel // ignore: cast_nullable_to_non_nullable
              as ContrastLevel,
      sizeClass: null == sizeClass
          ? _value.sizeClass
          : sizeClass // ignore: cast_nullable_to_non_nullable
              as SizeClass,
      enableAnimations: null == enableAnimations
          ? _value.enableAnimations
          : enableAnimations // ignore: cast_nullable_to_non_nullable
              as bool,
      enableHapticFeedback: null == enableHapticFeedback
          ? _value.enableHapticFeedback
          : enableHapticFeedback // ignore: cast_nullable_to_non_nullable
              as bool,
      enableSoundEffects: null == enableSoundEffects
          ? _value.enableSoundEffects
          : enableSoundEffects // ignore: cast_nullable_to_non_nullable
              as bool,
      animationSpeed: null == animationSpeed
          ? _value.animationSpeed
          : animationSpeed // ignore: cast_nullable_to_non_nullable
              as double,
      textScaleFactor: null == textScaleFactor
          ? _value.textScaleFactor
          : textScaleFactor // ignore: cast_nullable_to_non_nullable
              as double,
      iconScaleFactor: null == iconScaleFactor
          ? _value.iconScaleFactor
          : iconScaleFactor // ignore: cast_nullable_to_non_nullable
              as double,
      baseFontSize: null == baseFontSize
          ? _value.baseFontSize
          : baseFontSize // ignore: cast_nullable_to_non_nullable
              as double,
      lineHeight: null == lineHeight
          ? _value.lineHeight
          : lineHeight // ignore: cast_nullable_to_non_nullable
              as double,
      spacingUnit: null == spacingUnit
          ? _value.spacingUnit
          : spacingUnit // ignore: cast_nullable_to_non_nullable
              as double,
      borderRadius: null == borderRadius
          ? _value.borderRadius
          : borderRadius // ignore: cast_nullable_to_non_nullable
              as double,
      borderWidth: null == borderWidth
          ? _value.borderWidth
          : borderWidth // ignore: cast_nullable_to_non_nullable
              as double,
      elevation: null == elevation
          ? _value.elevation
          : elevation // ignore: cast_nullable_to_non_nullable
              as double,
      opacity: null == opacity
          ? _value.opacity
          : opacity // ignore: cast_nullable_to_non_nullable
              as double,
    ) as $Val);
  }

  /// Create a copy of ThemeConfig
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $PandoraThemeCopyWith<$Res> get pandoraTheme {
    return $PandoraThemeCopyWith<$Res>(_value.pandoraTheme, (value) {
      return _then(_value.copyWith(pandoraTheme: value) as $Val);
    });
  }

  /// Create a copy of ThemeConfig
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AccessibilityLevelCopyWith<$Res> get accessibilityLevel {
    return $AccessibilityLevelCopyWith<$Res>(_value.accessibilityLevel,
        (value) {
      return _then(_value.copyWith(accessibilityLevel: value) as $Val);
    });
  }

  /// Create a copy of ThemeConfig
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ContrastLevelCopyWith<$Res> get contrastLevel {
    return $ContrastLevelCopyWith<$Res>(_value.contrastLevel, (value) {
      return _then(_value.copyWith(contrastLevel: value) as $Val);
    });
  }

  /// Create a copy of ThemeConfig
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $SizeClassCopyWith<$Res> get sizeClass {
    return $SizeClassCopyWith<$Res>(_value.sizeClass, (value) {
      return _then(_value.copyWith(sizeClass: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ThemeConfigImplCopyWith<$Res>
    implements $ThemeConfigCopyWith<$Res> {
  factory _$$ThemeConfigImplCopyWith(
          _$ThemeConfigImpl value, $Res Function(_$ThemeConfigImpl) then) =
      __$$ThemeConfigImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {PandoraTheme pandoraTheme,
      @JsonKey(fromJson: _themeModeFromJson, toJson: _themeModeToJson)
      ThemeMode themeMode,
      AccessibilityLevel accessibilityLevel,
      ContrastLevel contrastLevel,
      SizeClass sizeClass,
      bool enableAnimations,
      bool enableHapticFeedback,
      bool enableSoundEffects,
      double animationSpeed,
      double textScaleFactor,
      double iconScaleFactor,
      double baseFontSize,
      double lineHeight,
      double spacingUnit,
      double borderRadius,
      double borderWidth,
      double elevation,
      double opacity});

  @override
  $PandoraThemeCopyWith<$Res> get pandoraTheme;
  @override
  $AccessibilityLevelCopyWith<$Res> get accessibilityLevel;
  @override
  $ContrastLevelCopyWith<$Res> get contrastLevel;
  @override
  $SizeClassCopyWith<$Res> get sizeClass;
}

/// @nodoc
class __$$ThemeConfigImplCopyWithImpl<$Res>
    extends _$ThemeConfigCopyWithImpl<$Res, _$ThemeConfigImpl>
    implements _$$ThemeConfigImplCopyWith<$Res> {
  __$$ThemeConfigImplCopyWithImpl(
      _$ThemeConfigImpl _value, $Res Function(_$ThemeConfigImpl) _then)
      : super(_value, _then);

  /// Create a copy of ThemeConfig
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? pandoraTheme = null,
    Object? themeMode = null,
    Object? accessibilityLevel = null,
    Object? contrastLevel = null,
    Object? sizeClass = null,
    Object? enableAnimations = null,
    Object? enableHapticFeedback = null,
    Object? enableSoundEffects = null,
    Object? animationSpeed = null,
    Object? textScaleFactor = null,
    Object? iconScaleFactor = null,
    Object? baseFontSize = null,
    Object? lineHeight = null,
    Object? spacingUnit = null,
    Object? borderRadius = null,
    Object? borderWidth = null,
    Object? elevation = null,
    Object? opacity = null,
  }) {
    return _then(_$ThemeConfigImpl(
      pandoraTheme: null == pandoraTheme
          ? _value.pandoraTheme
          : pandoraTheme // ignore: cast_nullable_to_non_nullable
              as PandoraTheme,
      themeMode: null == themeMode
          ? _value.themeMode
          : themeMode // ignore: cast_nullable_to_non_nullable
              as ThemeMode,
      accessibilityLevel: null == accessibilityLevel
          ? _value.accessibilityLevel
          : accessibilityLevel // ignore: cast_nullable_to_non_nullable
              as AccessibilityLevel,
      contrastLevel: null == contrastLevel
          ? _value.contrastLevel
          : contrastLevel // ignore: cast_nullable_to_non_nullable
              as ContrastLevel,
      sizeClass: null == sizeClass
          ? _value.sizeClass
          : sizeClass // ignore: cast_nullable_to_non_nullable
              as SizeClass,
      enableAnimations: null == enableAnimations
          ? _value.enableAnimations
          : enableAnimations // ignore: cast_nullable_to_non_nullable
              as bool,
      enableHapticFeedback: null == enableHapticFeedback
          ? _value.enableHapticFeedback
          : enableHapticFeedback // ignore: cast_nullable_to_non_nullable
              as bool,
      enableSoundEffects: null == enableSoundEffects
          ? _value.enableSoundEffects
          : enableSoundEffects // ignore: cast_nullable_to_non_nullable
              as bool,
      animationSpeed: null == animationSpeed
          ? _value.animationSpeed
          : animationSpeed // ignore: cast_nullable_to_non_nullable
              as double,
      textScaleFactor: null == textScaleFactor
          ? _value.textScaleFactor
          : textScaleFactor // ignore: cast_nullable_to_non_nullable
              as double,
      iconScaleFactor: null == iconScaleFactor
          ? _value.iconScaleFactor
          : iconScaleFactor // ignore: cast_nullable_to_non_nullable
              as double,
      baseFontSize: null == baseFontSize
          ? _value.baseFontSize
          : baseFontSize // ignore: cast_nullable_to_non_nullable
              as double,
      lineHeight: null == lineHeight
          ? _value.lineHeight
          : lineHeight // ignore: cast_nullable_to_non_nullable
              as double,
      spacingUnit: null == spacingUnit
          ? _value.spacingUnit
          : spacingUnit // ignore: cast_nullable_to_non_nullable
              as double,
      borderRadius: null == borderRadius
          ? _value.borderRadius
          : borderRadius // ignore: cast_nullable_to_non_nullable
              as double,
      borderWidth: null == borderWidth
          ? _value.borderWidth
          : borderWidth // ignore: cast_nullable_to_non_nullable
              as double,
      elevation: null == elevation
          ? _value.elevation
          : elevation // ignore: cast_nullable_to_non_nullable
              as double,
      opacity: null == opacity
          ? _value.opacity
          : opacity // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ThemeConfigImpl implements _ThemeConfig {
  const _$ThemeConfigImpl(
      {required this.pandoraTheme,
      @JsonKey(fromJson: _themeModeFromJson, toJson: _themeModeToJson)
      required this.themeMode,
      required this.accessibilityLevel,
      required this.contrastLevel,
      required this.sizeClass,
      this.enableAnimations = true,
      this.enableHapticFeedback = true,
      this.enableSoundEffects = true,
      this.animationSpeed = 1.0,
      this.textScaleFactor = 1.0,
      this.iconScaleFactor = 1.0,
      this.baseFontSize = 16.0,
      this.lineHeight = 1.5,
      this.spacingUnit = 8.0,
      this.borderRadius = 4.0,
      this.borderWidth = 2.0,
      this.elevation = 8.0,
      this.opacity = 0.1});

  factory _$ThemeConfigImpl.fromJson(Map<String, dynamic> json) =>
      _$$ThemeConfigImplFromJson(json);

  @override
  final PandoraTheme pandoraTheme;
  @override
  @JsonKey(fromJson: _themeModeFromJson, toJson: _themeModeToJson)
  final ThemeMode themeMode;
  @override
  final AccessibilityLevel accessibilityLevel;
  @override
  final ContrastLevel contrastLevel;
  @override
  final SizeClass sizeClass;
  @override
  @JsonKey()
  final bool enableAnimations;
  @override
  @JsonKey()
  final bool enableHapticFeedback;
  @override
  @JsonKey()
  final bool enableSoundEffects;
  @override
  @JsonKey()
  final double animationSpeed;
  @override
  @JsonKey()
  final double textScaleFactor;
  @override
  @JsonKey()
  final double iconScaleFactor;
  @override
  @JsonKey()
  final double baseFontSize;
  @override
  @JsonKey()
  final double lineHeight;
  @override
  @JsonKey()
  final double spacingUnit;
  @override
  @JsonKey()
  final double borderRadius;
  @override
  @JsonKey()
  final double borderWidth;
  @override
  @JsonKey()
  final double elevation;
  @override
  @JsonKey()
  final double opacity;

  @override
  String toString() {
    return 'ThemeConfig(pandoraTheme: $pandoraTheme, themeMode: $themeMode, accessibilityLevel: $accessibilityLevel, contrastLevel: $contrastLevel, sizeClass: $sizeClass, enableAnimations: $enableAnimations, enableHapticFeedback: $enableHapticFeedback, enableSoundEffects: $enableSoundEffects, animationSpeed: $animationSpeed, textScaleFactor: $textScaleFactor, iconScaleFactor: $iconScaleFactor, baseFontSize: $baseFontSize, lineHeight: $lineHeight, spacingUnit: $spacingUnit, borderRadius: $borderRadius, borderWidth: $borderWidth, elevation: $elevation, opacity: $opacity)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ThemeConfigImpl &&
            (identical(other.pandoraTheme, pandoraTheme) ||
                other.pandoraTheme == pandoraTheme) &&
            (identical(other.themeMode, themeMode) ||
                other.themeMode == themeMode) &&
            (identical(other.accessibilityLevel, accessibilityLevel) ||
                other.accessibilityLevel == accessibilityLevel) &&
            (identical(other.contrastLevel, contrastLevel) ||
                other.contrastLevel == contrastLevel) &&
            (identical(other.sizeClass, sizeClass) ||
                other.sizeClass == sizeClass) &&
            (identical(other.enableAnimations, enableAnimations) ||
                other.enableAnimations == enableAnimations) &&
            (identical(other.enableHapticFeedback, enableHapticFeedback) ||
                other.enableHapticFeedback == enableHapticFeedback) &&
            (identical(other.enableSoundEffects, enableSoundEffects) ||
                other.enableSoundEffects == enableSoundEffects) &&
            (identical(other.animationSpeed, animationSpeed) ||
                other.animationSpeed == animationSpeed) &&
            (identical(other.textScaleFactor, textScaleFactor) ||
                other.textScaleFactor == textScaleFactor) &&
            (identical(other.iconScaleFactor, iconScaleFactor) ||
                other.iconScaleFactor == iconScaleFactor) &&
            (identical(other.baseFontSize, baseFontSize) ||
                other.baseFontSize == baseFontSize) &&
            (identical(other.lineHeight, lineHeight) ||
                other.lineHeight == lineHeight) &&
            (identical(other.spacingUnit, spacingUnit) ||
                other.spacingUnit == spacingUnit) &&
            (identical(other.borderRadius, borderRadius) ||
                other.borderRadius == borderRadius) &&
            (identical(other.borderWidth, borderWidth) ||
                other.borderWidth == borderWidth) &&
            (identical(other.elevation, elevation) ||
                other.elevation == elevation) &&
            (identical(other.opacity, opacity) || other.opacity == opacity));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      pandoraTheme,
      themeMode,
      accessibilityLevel,
      contrastLevel,
      sizeClass,
      enableAnimations,
      enableHapticFeedback,
      enableSoundEffects,
      animationSpeed,
      textScaleFactor,
      iconScaleFactor,
      baseFontSize,
      lineHeight,
      spacingUnit,
      borderRadius,
      borderWidth,
      elevation,
      opacity);

  /// Create a copy of ThemeConfig
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ThemeConfigImplCopyWith<_$ThemeConfigImpl> get copyWith =>
      __$$ThemeConfigImplCopyWithImpl<_$ThemeConfigImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ThemeConfigImplToJson(
      this,
    );
  }
}

abstract class _ThemeConfig implements ThemeConfig {
  const factory _ThemeConfig(
      {required final PandoraTheme pandoraTheme,
      @JsonKey(fromJson: _themeModeFromJson, toJson: _themeModeToJson)
      required final ThemeMode themeMode,
      required final AccessibilityLevel accessibilityLevel,
      required final ContrastLevel contrastLevel,
      required final SizeClass sizeClass,
      final bool enableAnimations,
      final bool enableHapticFeedback,
      final bool enableSoundEffects,
      final double animationSpeed,
      final double textScaleFactor,
      final double iconScaleFactor,
      final double baseFontSize,
      final double lineHeight,
      final double spacingUnit,
      final double borderRadius,
      final double borderWidth,
      final double elevation,
      final double opacity}) = _$ThemeConfigImpl;

  factory _ThemeConfig.fromJson(Map<String, dynamic> json) =
      _$ThemeConfigImpl.fromJson;

  @override
  PandoraTheme get pandoraTheme;
  @override
  @JsonKey(fromJson: _themeModeFromJson, toJson: _themeModeToJson)
  ThemeMode get themeMode;
  @override
  AccessibilityLevel get accessibilityLevel;
  @override
  ContrastLevel get contrastLevel;
  @override
  SizeClass get sizeClass;
  @override
  bool get enableAnimations;
  @override
  bool get enableHapticFeedback;
  @override
  bool get enableSoundEffects;
  @override
  double get animationSpeed;
  @override
  double get textScaleFactor;
  @override
  double get iconScaleFactor;
  @override
  double get baseFontSize;
  @override
  double get lineHeight;
  @override
  double get spacingUnit;
  @override
  double get borderRadius;
  @override
  double get borderWidth;
  @override
  double get elevation;
  @override
  double get opacity;

  /// Create a copy of ThemeConfig
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ThemeConfigImplCopyWith<_$ThemeConfigImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

PandoraTheme _$PandoraThemeFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'classic':
      return ClassicTheme.fromJson(json);
    case 'modern':
      return ModernTheme.fromJson(json);
    case 'minimal':
      return MinimalTheme.fromJson(json);
    case 'dark':
      return DarkTheme.fromJson(json);
    case 'light':
      return LightTheme.fromJson(json);
    case 'auto':
      return AutoTheme.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'PandoraTheme',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$PandoraTheme {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() classic,
    required TResult Function() modern,
    required TResult Function() minimal,
    required TResult Function() dark,
    required TResult Function() light,
    required TResult Function() auto,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? classic,
    TResult? Function()? modern,
    TResult? Function()? minimal,
    TResult? Function()? dark,
    TResult? Function()? light,
    TResult? Function()? auto,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? classic,
    TResult Function()? modern,
    TResult Function()? minimal,
    TResult Function()? dark,
    TResult Function()? light,
    TResult Function()? auto,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ClassicTheme value) classic,
    required TResult Function(ModernTheme value) modern,
    required TResult Function(MinimalTheme value) minimal,
    required TResult Function(DarkTheme value) dark,
    required TResult Function(LightTheme value) light,
    required TResult Function(AutoTheme value) auto,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ClassicTheme value)? classic,
    TResult? Function(ModernTheme value)? modern,
    TResult? Function(MinimalTheme value)? minimal,
    TResult? Function(DarkTheme value)? dark,
    TResult? Function(LightTheme value)? light,
    TResult? Function(AutoTheme value)? auto,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ClassicTheme value)? classic,
    TResult Function(ModernTheme value)? modern,
    TResult Function(MinimalTheme value)? minimal,
    TResult Function(DarkTheme value)? dark,
    TResult Function(LightTheme value)? light,
    TResult Function(AutoTheme value)? auto,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  /// Serializes this PandoraTheme to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PandoraThemeCopyWith<$Res> {
  factory $PandoraThemeCopyWith(
          PandoraTheme value, $Res Function(PandoraTheme) then) =
      _$PandoraThemeCopyWithImpl<$Res, PandoraTheme>;
}

/// @nodoc
class _$PandoraThemeCopyWithImpl<$Res, $Val extends PandoraTheme>
    implements $PandoraThemeCopyWith<$Res> {
  _$PandoraThemeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of PandoraTheme
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$ClassicThemeImplCopyWith<$Res> {
  factory _$$ClassicThemeImplCopyWith(
          _$ClassicThemeImpl value, $Res Function(_$ClassicThemeImpl) then) =
      __$$ClassicThemeImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ClassicThemeImplCopyWithImpl<$Res>
    extends _$PandoraThemeCopyWithImpl<$Res, _$ClassicThemeImpl>
    implements _$$ClassicThemeImplCopyWith<$Res> {
  __$$ClassicThemeImplCopyWithImpl(
      _$ClassicThemeImpl _value, $Res Function(_$ClassicThemeImpl) _then)
      : super(_value, _then);

  /// Create a copy of PandoraTheme
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
@JsonSerializable()
class _$ClassicThemeImpl implements ClassicTheme {
  const _$ClassicThemeImpl({final String? $type}) : $type = $type ?? 'classic';

  factory _$ClassicThemeImpl.fromJson(Map<String, dynamic> json) =>
      _$$ClassicThemeImplFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'PandoraTheme.classic()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ClassicThemeImpl);
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() classic,
    required TResult Function() modern,
    required TResult Function() minimal,
    required TResult Function() dark,
    required TResult Function() light,
    required TResult Function() auto,
  }) {
    return classic();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? classic,
    TResult? Function()? modern,
    TResult? Function()? minimal,
    TResult? Function()? dark,
    TResult? Function()? light,
    TResult? Function()? auto,
  }) {
    return classic?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? classic,
    TResult Function()? modern,
    TResult Function()? minimal,
    TResult Function()? dark,
    TResult Function()? light,
    TResult Function()? auto,
    required TResult orElse(),
  }) {
    if (classic != null) {
      return classic();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ClassicTheme value) classic,
    required TResult Function(ModernTheme value) modern,
    required TResult Function(MinimalTheme value) minimal,
    required TResult Function(DarkTheme value) dark,
    required TResult Function(LightTheme value) light,
    required TResult Function(AutoTheme value) auto,
  }) {
    return classic(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ClassicTheme value)? classic,
    TResult? Function(ModernTheme value)? modern,
    TResult? Function(MinimalTheme value)? minimal,
    TResult? Function(DarkTheme value)? dark,
    TResult? Function(LightTheme value)? light,
    TResult? Function(AutoTheme value)? auto,
  }) {
    return classic?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ClassicTheme value)? classic,
    TResult Function(ModernTheme value)? modern,
    TResult Function(MinimalTheme value)? minimal,
    TResult Function(DarkTheme value)? dark,
    TResult Function(LightTheme value)? light,
    TResult Function(AutoTheme value)? auto,
    required TResult orElse(),
  }) {
    if (classic != null) {
      return classic(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ClassicThemeImplToJson(
      this,
    );
  }
}

abstract class ClassicTheme implements PandoraTheme {
  const factory ClassicTheme() = _$ClassicThemeImpl;

  factory ClassicTheme.fromJson(Map<String, dynamic> json) =
      _$ClassicThemeImpl.fromJson;
}

/// @nodoc
abstract class _$$ModernThemeImplCopyWith<$Res> {
  factory _$$ModernThemeImplCopyWith(
          _$ModernThemeImpl value, $Res Function(_$ModernThemeImpl) then) =
      __$$ModernThemeImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ModernThemeImplCopyWithImpl<$Res>
    extends _$PandoraThemeCopyWithImpl<$Res, _$ModernThemeImpl>
    implements _$$ModernThemeImplCopyWith<$Res> {
  __$$ModernThemeImplCopyWithImpl(
      _$ModernThemeImpl _value, $Res Function(_$ModernThemeImpl) _then)
      : super(_value, _then);

  /// Create a copy of PandoraTheme
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
@JsonSerializable()
class _$ModernThemeImpl implements ModernTheme {
  const _$ModernThemeImpl({final String? $type}) : $type = $type ?? 'modern';

  factory _$ModernThemeImpl.fromJson(Map<String, dynamic> json) =>
      _$$ModernThemeImplFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'PandoraTheme.modern()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ModernThemeImpl);
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() classic,
    required TResult Function() modern,
    required TResult Function() minimal,
    required TResult Function() dark,
    required TResult Function() light,
    required TResult Function() auto,
  }) {
    return modern();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? classic,
    TResult? Function()? modern,
    TResult? Function()? minimal,
    TResult? Function()? dark,
    TResult? Function()? light,
    TResult? Function()? auto,
  }) {
    return modern?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? classic,
    TResult Function()? modern,
    TResult Function()? minimal,
    TResult Function()? dark,
    TResult Function()? light,
    TResult Function()? auto,
    required TResult orElse(),
  }) {
    if (modern != null) {
      return modern();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ClassicTheme value) classic,
    required TResult Function(ModernTheme value) modern,
    required TResult Function(MinimalTheme value) minimal,
    required TResult Function(DarkTheme value) dark,
    required TResult Function(LightTheme value) light,
    required TResult Function(AutoTheme value) auto,
  }) {
    return modern(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ClassicTheme value)? classic,
    TResult? Function(ModernTheme value)? modern,
    TResult? Function(MinimalTheme value)? minimal,
    TResult? Function(DarkTheme value)? dark,
    TResult? Function(LightTheme value)? light,
    TResult? Function(AutoTheme value)? auto,
  }) {
    return modern?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ClassicTheme value)? classic,
    TResult Function(ModernTheme value)? modern,
    TResult Function(MinimalTheme value)? minimal,
    TResult Function(DarkTheme value)? dark,
    TResult Function(LightTheme value)? light,
    TResult Function(AutoTheme value)? auto,
    required TResult orElse(),
  }) {
    if (modern != null) {
      return modern(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ModernThemeImplToJson(
      this,
    );
  }
}

abstract class ModernTheme implements PandoraTheme {
  const factory ModernTheme() = _$ModernThemeImpl;

  factory ModernTheme.fromJson(Map<String, dynamic> json) =
      _$ModernThemeImpl.fromJson;
}

/// @nodoc
abstract class _$$MinimalThemeImplCopyWith<$Res> {
  factory _$$MinimalThemeImplCopyWith(
          _$MinimalThemeImpl value, $Res Function(_$MinimalThemeImpl) then) =
      __$$MinimalThemeImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MinimalThemeImplCopyWithImpl<$Res>
    extends _$PandoraThemeCopyWithImpl<$Res, _$MinimalThemeImpl>
    implements _$$MinimalThemeImplCopyWith<$Res> {
  __$$MinimalThemeImplCopyWithImpl(
      _$MinimalThemeImpl _value, $Res Function(_$MinimalThemeImpl) _then)
      : super(_value, _then);

  /// Create a copy of PandoraTheme
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
@JsonSerializable()
class _$MinimalThemeImpl implements MinimalTheme {
  const _$MinimalThemeImpl({final String? $type}) : $type = $type ?? 'minimal';

  factory _$MinimalThemeImpl.fromJson(Map<String, dynamic> json) =>
      _$$MinimalThemeImplFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'PandoraTheme.minimal()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$MinimalThemeImpl);
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() classic,
    required TResult Function() modern,
    required TResult Function() minimal,
    required TResult Function() dark,
    required TResult Function() light,
    required TResult Function() auto,
  }) {
    return minimal();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? classic,
    TResult? Function()? modern,
    TResult? Function()? minimal,
    TResult? Function()? dark,
    TResult? Function()? light,
    TResult? Function()? auto,
  }) {
    return minimal?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? classic,
    TResult Function()? modern,
    TResult Function()? minimal,
    TResult Function()? dark,
    TResult Function()? light,
    TResult Function()? auto,
    required TResult orElse(),
  }) {
    if (minimal != null) {
      return minimal();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ClassicTheme value) classic,
    required TResult Function(ModernTheme value) modern,
    required TResult Function(MinimalTheme value) minimal,
    required TResult Function(DarkTheme value) dark,
    required TResult Function(LightTheme value) light,
    required TResult Function(AutoTheme value) auto,
  }) {
    return minimal(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ClassicTheme value)? classic,
    TResult? Function(ModernTheme value)? modern,
    TResult? Function(MinimalTheme value)? minimal,
    TResult? Function(DarkTheme value)? dark,
    TResult? Function(LightTheme value)? light,
    TResult? Function(AutoTheme value)? auto,
  }) {
    return minimal?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ClassicTheme value)? classic,
    TResult Function(ModernTheme value)? modern,
    TResult Function(MinimalTheme value)? minimal,
    TResult Function(DarkTheme value)? dark,
    TResult Function(LightTheme value)? light,
    TResult Function(AutoTheme value)? auto,
    required TResult orElse(),
  }) {
    if (minimal != null) {
      return minimal(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$MinimalThemeImplToJson(
      this,
    );
  }
}

abstract class MinimalTheme implements PandoraTheme {
  const factory MinimalTheme() = _$MinimalThemeImpl;

  factory MinimalTheme.fromJson(Map<String, dynamic> json) =
      _$MinimalThemeImpl.fromJson;
}

/// @nodoc
abstract class _$$DarkThemeImplCopyWith<$Res> {
  factory _$$DarkThemeImplCopyWith(
          _$DarkThemeImpl value, $Res Function(_$DarkThemeImpl) then) =
      __$$DarkThemeImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DarkThemeImplCopyWithImpl<$Res>
    extends _$PandoraThemeCopyWithImpl<$Res, _$DarkThemeImpl>
    implements _$$DarkThemeImplCopyWith<$Res> {
  __$$DarkThemeImplCopyWithImpl(
      _$DarkThemeImpl _value, $Res Function(_$DarkThemeImpl) _then)
      : super(_value, _then);

  /// Create a copy of PandoraTheme
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
@JsonSerializable()
class _$DarkThemeImpl implements DarkTheme {
  const _$DarkThemeImpl({final String? $type}) : $type = $type ?? 'dark';

  factory _$DarkThemeImpl.fromJson(Map<String, dynamic> json) =>
      _$$DarkThemeImplFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'PandoraTheme.dark()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DarkThemeImpl);
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() classic,
    required TResult Function() modern,
    required TResult Function() minimal,
    required TResult Function() dark,
    required TResult Function() light,
    required TResult Function() auto,
  }) {
    return dark();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? classic,
    TResult? Function()? modern,
    TResult? Function()? minimal,
    TResult? Function()? dark,
    TResult? Function()? light,
    TResult? Function()? auto,
  }) {
    return dark?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? classic,
    TResult Function()? modern,
    TResult Function()? minimal,
    TResult Function()? dark,
    TResult Function()? light,
    TResult Function()? auto,
    required TResult orElse(),
  }) {
    if (dark != null) {
      return dark();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ClassicTheme value) classic,
    required TResult Function(ModernTheme value) modern,
    required TResult Function(MinimalTheme value) minimal,
    required TResult Function(DarkTheme value) dark,
    required TResult Function(LightTheme value) light,
    required TResult Function(AutoTheme value) auto,
  }) {
    return dark(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ClassicTheme value)? classic,
    TResult? Function(ModernTheme value)? modern,
    TResult? Function(MinimalTheme value)? minimal,
    TResult? Function(DarkTheme value)? dark,
    TResult? Function(LightTheme value)? light,
    TResult? Function(AutoTheme value)? auto,
  }) {
    return dark?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ClassicTheme value)? classic,
    TResult Function(ModernTheme value)? modern,
    TResult Function(MinimalTheme value)? minimal,
    TResult Function(DarkTheme value)? dark,
    TResult Function(LightTheme value)? light,
    TResult Function(AutoTheme value)? auto,
    required TResult orElse(),
  }) {
    if (dark != null) {
      return dark(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$DarkThemeImplToJson(
      this,
    );
  }
}

abstract class DarkTheme implements PandoraTheme {
  const factory DarkTheme() = _$DarkThemeImpl;

  factory DarkTheme.fromJson(Map<String, dynamic> json) =
      _$DarkThemeImpl.fromJson;
}

/// @nodoc
abstract class _$$LightThemeImplCopyWith<$Res> {
  factory _$$LightThemeImplCopyWith(
          _$LightThemeImpl value, $Res Function(_$LightThemeImpl) then) =
      __$$LightThemeImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LightThemeImplCopyWithImpl<$Res>
    extends _$PandoraThemeCopyWithImpl<$Res, _$LightThemeImpl>
    implements _$$LightThemeImplCopyWith<$Res> {
  __$$LightThemeImplCopyWithImpl(
      _$LightThemeImpl _value, $Res Function(_$LightThemeImpl) _then)
      : super(_value, _then);

  /// Create a copy of PandoraTheme
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
@JsonSerializable()
class _$LightThemeImpl implements LightTheme {
  const _$LightThemeImpl({final String? $type}) : $type = $type ?? 'light';

  factory _$LightThemeImpl.fromJson(Map<String, dynamic> json) =>
      _$$LightThemeImplFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'PandoraTheme.light()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LightThemeImpl);
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() classic,
    required TResult Function() modern,
    required TResult Function() minimal,
    required TResult Function() dark,
    required TResult Function() light,
    required TResult Function() auto,
  }) {
    return light();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? classic,
    TResult? Function()? modern,
    TResult? Function()? minimal,
    TResult? Function()? dark,
    TResult? Function()? light,
    TResult? Function()? auto,
  }) {
    return light?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? classic,
    TResult Function()? modern,
    TResult Function()? minimal,
    TResult Function()? dark,
    TResult Function()? light,
    TResult Function()? auto,
    required TResult orElse(),
  }) {
    if (light != null) {
      return light();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ClassicTheme value) classic,
    required TResult Function(ModernTheme value) modern,
    required TResult Function(MinimalTheme value) minimal,
    required TResult Function(DarkTheme value) dark,
    required TResult Function(LightTheme value) light,
    required TResult Function(AutoTheme value) auto,
  }) {
    return light(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ClassicTheme value)? classic,
    TResult? Function(ModernTheme value)? modern,
    TResult? Function(MinimalTheme value)? minimal,
    TResult? Function(DarkTheme value)? dark,
    TResult? Function(LightTheme value)? light,
    TResult? Function(AutoTheme value)? auto,
  }) {
    return light?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ClassicTheme value)? classic,
    TResult Function(ModernTheme value)? modern,
    TResult Function(MinimalTheme value)? minimal,
    TResult Function(DarkTheme value)? dark,
    TResult Function(LightTheme value)? light,
    TResult Function(AutoTheme value)? auto,
    required TResult orElse(),
  }) {
    if (light != null) {
      return light(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$LightThemeImplToJson(
      this,
    );
  }
}

abstract class LightTheme implements PandoraTheme {
  const factory LightTheme() = _$LightThemeImpl;

  factory LightTheme.fromJson(Map<String, dynamic> json) =
      _$LightThemeImpl.fromJson;
}

/// @nodoc
abstract class _$$AutoThemeImplCopyWith<$Res> {
  factory _$$AutoThemeImplCopyWith(
          _$AutoThemeImpl value, $Res Function(_$AutoThemeImpl) then) =
      __$$AutoThemeImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AutoThemeImplCopyWithImpl<$Res>
    extends _$PandoraThemeCopyWithImpl<$Res, _$AutoThemeImpl>
    implements _$$AutoThemeImplCopyWith<$Res> {
  __$$AutoThemeImplCopyWithImpl(
      _$AutoThemeImpl _value, $Res Function(_$AutoThemeImpl) _then)
      : super(_value, _then);

  /// Create a copy of PandoraTheme
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
@JsonSerializable()
class _$AutoThemeImpl implements AutoTheme {
  const _$AutoThemeImpl({final String? $type}) : $type = $type ?? 'auto';

  factory _$AutoThemeImpl.fromJson(Map<String, dynamic> json) =>
      _$$AutoThemeImplFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'PandoraTheme.auto()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$AutoThemeImpl);
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() classic,
    required TResult Function() modern,
    required TResult Function() minimal,
    required TResult Function() dark,
    required TResult Function() light,
    required TResult Function() auto,
  }) {
    return auto();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? classic,
    TResult? Function()? modern,
    TResult? Function()? minimal,
    TResult? Function()? dark,
    TResult? Function()? light,
    TResult? Function()? auto,
  }) {
    return auto?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? classic,
    TResult Function()? modern,
    TResult Function()? minimal,
    TResult Function()? dark,
    TResult Function()? light,
    TResult Function()? auto,
    required TResult orElse(),
  }) {
    if (auto != null) {
      return auto();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ClassicTheme value) classic,
    required TResult Function(ModernTheme value) modern,
    required TResult Function(MinimalTheme value) minimal,
    required TResult Function(DarkTheme value) dark,
    required TResult Function(LightTheme value) light,
    required TResult Function(AutoTheme value) auto,
  }) {
    return auto(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ClassicTheme value)? classic,
    TResult? Function(ModernTheme value)? modern,
    TResult? Function(MinimalTheme value)? minimal,
    TResult? Function(DarkTheme value)? dark,
    TResult? Function(LightTheme value)? light,
    TResult? Function(AutoTheme value)? auto,
  }) {
    return auto?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ClassicTheme value)? classic,
    TResult Function(ModernTheme value)? modern,
    TResult Function(MinimalTheme value)? minimal,
    TResult Function(DarkTheme value)? dark,
    TResult Function(LightTheme value)? light,
    TResult Function(AutoTheme value)? auto,
    required TResult orElse(),
  }) {
    if (auto != null) {
      return auto(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$AutoThemeImplToJson(
      this,
    );
  }
}

abstract class AutoTheme implements PandoraTheme {
  const factory AutoTheme() = _$AutoThemeImpl;

  factory AutoTheme.fromJson(Map<String, dynamic> json) =
      _$AutoThemeImpl.fromJson;
}

AccessibilityLevel _$AccessibilityLevelFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'none':
      return NoneAccessibility.fromJson(json);
    case 'basic':
      return BasicAccessibility.fromJson(json);
    case 'enhanced':
      return EnhancedAccessibility.fromJson(json);
    case 'maximum':
      return MaximumAccessibility.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'AccessibilityLevel',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$AccessibilityLevel {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function() basic,
    required TResult Function() enhanced,
    required TResult Function() maximum,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? none,
    TResult? Function()? basic,
    TResult? Function()? enhanced,
    TResult? Function()? maximum,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? basic,
    TResult Function()? enhanced,
    TResult Function()? maximum,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoneAccessibility value) none,
    required TResult Function(BasicAccessibility value) basic,
    required TResult Function(EnhancedAccessibility value) enhanced,
    required TResult Function(MaximumAccessibility value) maximum,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NoneAccessibility value)? none,
    TResult? Function(BasicAccessibility value)? basic,
    TResult? Function(EnhancedAccessibility value)? enhanced,
    TResult? Function(MaximumAccessibility value)? maximum,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoneAccessibility value)? none,
    TResult Function(BasicAccessibility value)? basic,
    TResult Function(EnhancedAccessibility value)? enhanced,
    TResult Function(MaximumAccessibility value)? maximum,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  /// Serializes this AccessibilityLevel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AccessibilityLevelCopyWith<$Res> {
  factory $AccessibilityLevelCopyWith(
          AccessibilityLevel value, $Res Function(AccessibilityLevel) then) =
      _$AccessibilityLevelCopyWithImpl<$Res, AccessibilityLevel>;
}

/// @nodoc
class _$AccessibilityLevelCopyWithImpl<$Res, $Val extends AccessibilityLevel>
    implements $AccessibilityLevelCopyWith<$Res> {
  _$AccessibilityLevelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AccessibilityLevel
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$NoneAccessibilityImplCopyWith<$Res> {
  factory _$$NoneAccessibilityImplCopyWith(_$NoneAccessibilityImpl value,
          $Res Function(_$NoneAccessibilityImpl) then) =
      __$$NoneAccessibilityImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NoneAccessibilityImplCopyWithImpl<$Res>
    extends _$AccessibilityLevelCopyWithImpl<$Res, _$NoneAccessibilityImpl>
    implements _$$NoneAccessibilityImplCopyWith<$Res> {
  __$$NoneAccessibilityImplCopyWithImpl(_$NoneAccessibilityImpl _value,
      $Res Function(_$NoneAccessibilityImpl) _then)
      : super(_value, _then);

  /// Create a copy of AccessibilityLevel
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
@JsonSerializable()
class _$NoneAccessibilityImpl implements NoneAccessibility {
  const _$NoneAccessibilityImpl({final String? $type})
      : $type = $type ?? 'none';

  factory _$NoneAccessibilityImpl.fromJson(Map<String, dynamic> json) =>
      _$$NoneAccessibilityImplFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'AccessibilityLevel.none()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NoneAccessibilityImpl);
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function() basic,
    required TResult Function() enhanced,
    required TResult Function() maximum,
  }) {
    return none();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? none,
    TResult? Function()? basic,
    TResult? Function()? enhanced,
    TResult? Function()? maximum,
  }) {
    return none?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? basic,
    TResult Function()? enhanced,
    TResult Function()? maximum,
    required TResult orElse(),
  }) {
    if (none != null) {
      return none();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoneAccessibility value) none,
    required TResult Function(BasicAccessibility value) basic,
    required TResult Function(EnhancedAccessibility value) enhanced,
    required TResult Function(MaximumAccessibility value) maximum,
  }) {
    return none(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NoneAccessibility value)? none,
    TResult? Function(BasicAccessibility value)? basic,
    TResult? Function(EnhancedAccessibility value)? enhanced,
    TResult? Function(MaximumAccessibility value)? maximum,
  }) {
    return none?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoneAccessibility value)? none,
    TResult Function(BasicAccessibility value)? basic,
    TResult Function(EnhancedAccessibility value)? enhanced,
    TResult Function(MaximumAccessibility value)? maximum,
    required TResult orElse(),
  }) {
    if (none != null) {
      return none(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$NoneAccessibilityImplToJson(
      this,
    );
  }
}

abstract class NoneAccessibility implements AccessibilityLevel {
  const factory NoneAccessibility() = _$NoneAccessibilityImpl;

  factory NoneAccessibility.fromJson(Map<String, dynamic> json) =
      _$NoneAccessibilityImpl.fromJson;
}

/// @nodoc
abstract class _$$BasicAccessibilityImplCopyWith<$Res> {
  factory _$$BasicAccessibilityImplCopyWith(_$BasicAccessibilityImpl value,
          $Res Function(_$BasicAccessibilityImpl) then) =
      __$$BasicAccessibilityImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$BasicAccessibilityImplCopyWithImpl<$Res>
    extends _$AccessibilityLevelCopyWithImpl<$Res, _$BasicAccessibilityImpl>
    implements _$$BasicAccessibilityImplCopyWith<$Res> {
  __$$BasicAccessibilityImplCopyWithImpl(_$BasicAccessibilityImpl _value,
      $Res Function(_$BasicAccessibilityImpl) _then)
      : super(_value, _then);

  /// Create a copy of AccessibilityLevel
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
@JsonSerializable()
class _$BasicAccessibilityImpl implements BasicAccessibility {
  const _$BasicAccessibilityImpl({final String? $type})
      : $type = $type ?? 'basic';

  factory _$BasicAccessibilityImpl.fromJson(Map<String, dynamic> json) =>
      _$$BasicAccessibilityImplFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'AccessibilityLevel.basic()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$BasicAccessibilityImpl);
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function() basic,
    required TResult Function() enhanced,
    required TResult Function() maximum,
  }) {
    return basic();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? none,
    TResult? Function()? basic,
    TResult? Function()? enhanced,
    TResult? Function()? maximum,
  }) {
    return basic?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? basic,
    TResult Function()? enhanced,
    TResult Function()? maximum,
    required TResult orElse(),
  }) {
    if (basic != null) {
      return basic();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoneAccessibility value) none,
    required TResult Function(BasicAccessibility value) basic,
    required TResult Function(EnhancedAccessibility value) enhanced,
    required TResult Function(MaximumAccessibility value) maximum,
  }) {
    return basic(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NoneAccessibility value)? none,
    TResult? Function(BasicAccessibility value)? basic,
    TResult? Function(EnhancedAccessibility value)? enhanced,
    TResult? Function(MaximumAccessibility value)? maximum,
  }) {
    return basic?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoneAccessibility value)? none,
    TResult Function(BasicAccessibility value)? basic,
    TResult Function(EnhancedAccessibility value)? enhanced,
    TResult Function(MaximumAccessibility value)? maximum,
    required TResult orElse(),
  }) {
    if (basic != null) {
      return basic(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$BasicAccessibilityImplToJson(
      this,
    );
  }
}

abstract class BasicAccessibility implements AccessibilityLevel {
  const factory BasicAccessibility() = _$BasicAccessibilityImpl;

  factory BasicAccessibility.fromJson(Map<String, dynamic> json) =
      _$BasicAccessibilityImpl.fromJson;
}

/// @nodoc
abstract class _$$EnhancedAccessibilityImplCopyWith<$Res> {
  factory _$$EnhancedAccessibilityImplCopyWith(
          _$EnhancedAccessibilityImpl value,
          $Res Function(_$EnhancedAccessibilityImpl) then) =
      __$$EnhancedAccessibilityImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$EnhancedAccessibilityImplCopyWithImpl<$Res>
    extends _$AccessibilityLevelCopyWithImpl<$Res, _$EnhancedAccessibilityImpl>
    implements _$$EnhancedAccessibilityImplCopyWith<$Res> {
  __$$EnhancedAccessibilityImplCopyWithImpl(_$EnhancedAccessibilityImpl _value,
      $Res Function(_$EnhancedAccessibilityImpl) _then)
      : super(_value, _then);

  /// Create a copy of AccessibilityLevel
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
@JsonSerializable()
class _$EnhancedAccessibilityImpl implements EnhancedAccessibility {
  const _$EnhancedAccessibilityImpl({final String? $type})
      : $type = $type ?? 'enhanced';

  factory _$EnhancedAccessibilityImpl.fromJson(Map<String, dynamic> json) =>
      _$$EnhancedAccessibilityImplFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'AccessibilityLevel.enhanced()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EnhancedAccessibilityImpl);
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function() basic,
    required TResult Function() enhanced,
    required TResult Function() maximum,
  }) {
    return enhanced();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? none,
    TResult? Function()? basic,
    TResult? Function()? enhanced,
    TResult? Function()? maximum,
  }) {
    return enhanced?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? basic,
    TResult Function()? enhanced,
    TResult Function()? maximum,
    required TResult orElse(),
  }) {
    if (enhanced != null) {
      return enhanced();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoneAccessibility value) none,
    required TResult Function(BasicAccessibility value) basic,
    required TResult Function(EnhancedAccessibility value) enhanced,
    required TResult Function(MaximumAccessibility value) maximum,
  }) {
    return enhanced(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NoneAccessibility value)? none,
    TResult? Function(BasicAccessibility value)? basic,
    TResult? Function(EnhancedAccessibility value)? enhanced,
    TResult? Function(MaximumAccessibility value)? maximum,
  }) {
    return enhanced?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoneAccessibility value)? none,
    TResult Function(BasicAccessibility value)? basic,
    TResult Function(EnhancedAccessibility value)? enhanced,
    TResult Function(MaximumAccessibility value)? maximum,
    required TResult orElse(),
  }) {
    if (enhanced != null) {
      return enhanced(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$EnhancedAccessibilityImplToJson(
      this,
    );
  }
}

abstract class EnhancedAccessibility implements AccessibilityLevel {
  const factory EnhancedAccessibility() = _$EnhancedAccessibilityImpl;

  factory EnhancedAccessibility.fromJson(Map<String, dynamic> json) =
      _$EnhancedAccessibilityImpl.fromJson;
}

/// @nodoc
abstract class _$$MaximumAccessibilityImplCopyWith<$Res> {
  factory _$$MaximumAccessibilityImplCopyWith(_$MaximumAccessibilityImpl value,
          $Res Function(_$MaximumAccessibilityImpl) then) =
      __$$MaximumAccessibilityImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MaximumAccessibilityImplCopyWithImpl<$Res>
    extends _$AccessibilityLevelCopyWithImpl<$Res, _$MaximumAccessibilityImpl>
    implements _$$MaximumAccessibilityImplCopyWith<$Res> {
  __$$MaximumAccessibilityImplCopyWithImpl(_$MaximumAccessibilityImpl _value,
      $Res Function(_$MaximumAccessibilityImpl) _then)
      : super(_value, _then);

  /// Create a copy of AccessibilityLevel
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
@JsonSerializable()
class _$MaximumAccessibilityImpl implements MaximumAccessibility {
  const _$MaximumAccessibilityImpl({final String? $type})
      : $type = $type ?? 'maximum';

  factory _$MaximumAccessibilityImpl.fromJson(Map<String, dynamic> json) =>
      _$$MaximumAccessibilityImplFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'AccessibilityLevel.maximum()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MaximumAccessibilityImpl);
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function() basic,
    required TResult Function() enhanced,
    required TResult Function() maximum,
  }) {
    return maximum();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? none,
    TResult? Function()? basic,
    TResult? Function()? enhanced,
    TResult? Function()? maximum,
  }) {
    return maximum?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function()? basic,
    TResult Function()? enhanced,
    TResult Function()? maximum,
    required TResult orElse(),
  }) {
    if (maximum != null) {
      return maximum();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoneAccessibility value) none,
    required TResult Function(BasicAccessibility value) basic,
    required TResult Function(EnhancedAccessibility value) enhanced,
    required TResult Function(MaximumAccessibility value) maximum,
  }) {
    return maximum(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NoneAccessibility value)? none,
    TResult? Function(BasicAccessibility value)? basic,
    TResult? Function(EnhancedAccessibility value)? enhanced,
    TResult? Function(MaximumAccessibility value)? maximum,
  }) {
    return maximum?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoneAccessibility value)? none,
    TResult Function(BasicAccessibility value)? basic,
    TResult Function(EnhancedAccessibility value)? enhanced,
    TResult Function(MaximumAccessibility value)? maximum,
    required TResult orElse(),
  }) {
    if (maximum != null) {
      return maximum(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$MaximumAccessibilityImplToJson(
      this,
    );
  }
}

abstract class MaximumAccessibility implements AccessibilityLevel {
  const factory MaximumAccessibility() = _$MaximumAccessibilityImpl;

  factory MaximumAccessibility.fromJson(Map<String, dynamic> json) =
      _$MaximumAccessibilityImpl.fromJson;
}

ContrastLevel _$ContrastLevelFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'normal':
      return NormalContrast.fromJson(json);
    case 'high':
      return HighContrast.fromJson(json);
    case 'maximum':
      return MaximumContrast.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'ContrastLevel',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ContrastLevel {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() normal,
    required TResult Function() high,
    required TResult Function() maximum,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? normal,
    TResult? Function()? high,
    TResult? Function()? maximum,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? normal,
    TResult Function()? high,
    TResult Function()? maximum,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NormalContrast value) normal,
    required TResult Function(HighContrast value) high,
    required TResult Function(MaximumContrast value) maximum,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NormalContrast value)? normal,
    TResult? Function(HighContrast value)? high,
    TResult? Function(MaximumContrast value)? maximum,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NormalContrast value)? normal,
    TResult Function(HighContrast value)? high,
    TResult Function(MaximumContrast value)? maximum,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  /// Serializes this ContrastLevel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ContrastLevelCopyWith<$Res> {
  factory $ContrastLevelCopyWith(
          ContrastLevel value, $Res Function(ContrastLevel) then) =
      _$ContrastLevelCopyWithImpl<$Res, ContrastLevel>;
}

/// @nodoc
class _$ContrastLevelCopyWithImpl<$Res, $Val extends ContrastLevel>
    implements $ContrastLevelCopyWith<$Res> {
  _$ContrastLevelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ContrastLevel
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$NormalContrastImplCopyWith<$Res> {
  factory _$$NormalContrastImplCopyWith(_$NormalContrastImpl value,
          $Res Function(_$NormalContrastImpl) then) =
      __$$NormalContrastImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NormalContrastImplCopyWithImpl<$Res>
    extends _$ContrastLevelCopyWithImpl<$Res, _$NormalContrastImpl>
    implements _$$NormalContrastImplCopyWith<$Res> {
  __$$NormalContrastImplCopyWithImpl(
      _$NormalContrastImpl _value, $Res Function(_$NormalContrastImpl) _then)
      : super(_value, _then);

  /// Create a copy of ContrastLevel
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
@JsonSerializable()
class _$NormalContrastImpl implements NormalContrast {
  const _$NormalContrastImpl({final String? $type}) : $type = $type ?? 'normal';

  factory _$NormalContrastImpl.fromJson(Map<String, dynamic> json) =>
      _$$NormalContrastImplFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ContrastLevel.normal()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NormalContrastImpl);
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() normal,
    required TResult Function() high,
    required TResult Function() maximum,
  }) {
    return normal();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? normal,
    TResult? Function()? high,
    TResult? Function()? maximum,
  }) {
    return normal?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? normal,
    TResult Function()? high,
    TResult Function()? maximum,
    required TResult orElse(),
  }) {
    if (normal != null) {
      return normal();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NormalContrast value) normal,
    required TResult Function(HighContrast value) high,
    required TResult Function(MaximumContrast value) maximum,
  }) {
    return normal(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NormalContrast value)? normal,
    TResult? Function(HighContrast value)? high,
    TResult? Function(MaximumContrast value)? maximum,
  }) {
    return normal?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NormalContrast value)? normal,
    TResult Function(HighContrast value)? high,
    TResult Function(MaximumContrast value)? maximum,
    required TResult orElse(),
  }) {
    if (normal != null) {
      return normal(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$NormalContrastImplToJson(
      this,
    );
  }
}

abstract class NormalContrast implements ContrastLevel {
  const factory NormalContrast() = _$NormalContrastImpl;

  factory NormalContrast.fromJson(Map<String, dynamic> json) =
      _$NormalContrastImpl.fromJson;
}

/// @nodoc
abstract class _$$HighContrastImplCopyWith<$Res> {
  factory _$$HighContrastImplCopyWith(
          _$HighContrastImpl value, $Res Function(_$HighContrastImpl) then) =
      __$$HighContrastImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$HighContrastImplCopyWithImpl<$Res>
    extends _$ContrastLevelCopyWithImpl<$Res, _$HighContrastImpl>
    implements _$$HighContrastImplCopyWith<$Res> {
  __$$HighContrastImplCopyWithImpl(
      _$HighContrastImpl _value, $Res Function(_$HighContrastImpl) _then)
      : super(_value, _then);

  /// Create a copy of ContrastLevel
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
@JsonSerializable()
class _$HighContrastImpl implements HighContrast {
  const _$HighContrastImpl({final String? $type}) : $type = $type ?? 'high';

  factory _$HighContrastImpl.fromJson(Map<String, dynamic> json) =>
      _$$HighContrastImplFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ContrastLevel.high()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$HighContrastImpl);
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() normal,
    required TResult Function() high,
    required TResult Function() maximum,
  }) {
    return high();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? normal,
    TResult? Function()? high,
    TResult? Function()? maximum,
  }) {
    return high?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? normal,
    TResult Function()? high,
    TResult Function()? maximum,
    required TResult orElse(),
  }) {
    if (high != null) {
      return high();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NormalContrast value) normal,
    required TResult Function(HighContrast value) high,
    required TResult Function(MaximumContrast value) maximum,
  }) {
    return high(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NormalContrast value)? normal,
    TResult? Function(HighContrast value)? high,
    TResult? Function(MaximumContrast value)? maximum,
  }) {
    return high?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NormalContrast value)? normal,
    TResult Function(HighContrast value)? high,
    TResult Function(MaximumContrast value)? maximum,
    required TResult orElse(),
  }) {
    if (high != null) {
      return high(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$HighContrastImplToJson(
      this,
    );
  }
}

abstract class HighContrast implements ContrastLevel {
  const factory HighContrast() = _$HighContrastImpl;

  factory HighContrast.fromJson(Map<String, dynamic> json) =
      _$HighContrastImpl.fromJson;
}

/// @nodoc
abstract class _$$MaximumContrastImplCopyWith<$Res> {
  factory _$$MaximumContrastImplCopyWith(_$MaximumContrastImpl value,
          $Res Function(_$MaximumContrastImpl) then) =
      __$$MaximumContrastImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MaximumContrastImplCopyWithImpl<$Res>
    extends _$ContrastLevelCopyWithImpl<$Res, _$MaximumContrastImpl>
    implements _$$MaximumContrastImplCopyWith<$Res> {
  __$$MaximumContrastImplCopyWithImpl(
      _$MaximumContrastImpl _value, $Res Function(_$MaximumContrastImpl) _then)
      : super(_value, _then);

  /// Create a copy of ContrastLevel
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
@JsonSerializable()
class _$MaximumContrastImpl implements MaximumContrast {
  const _$MaximumContrastImpl({final String? $type})
      : $type = $type ?? 'maximum';

  factory _$MaximumContrastImpl.fromJson(Map<String, dynamic> json) =>
      _$$MaximumContrastImplFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ContrastLevel.maximum()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$MaximumContrastImpl);
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() normal,
    required TResult Function() high,
    required TResult Function() maximum,
  }) {
    return maximum();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? normal,
    TResult? Function()? high,
    TResult? Function()? maximum,
  }) {
    return maximum?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? normal,
    TResult Function()? high,
    TResult Function()? maximum,
    required TResult orElse(),
  }) {
    if (maximum != null) {
      return maximum();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NormalContrast value) normal,
    required TResult Function(HighContrast value) high,
    required TResult Function(MaximumContrast value) maximum,
  }) {
    return maximum(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NormalContrast value)? normal,
    TResult? Function(HighContrast value)? high,
    TResult? Function(MaximumContrast value)? maximum,
  }) {
    return maximum?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NormalContrast value)? normal,
    TResult Function(HighContrast value)? high,
    TResult Function(MaximumContrast value)? maximum,
    required TResult orElse(),
  }) {
    if (maximum != null) {
      return maximum(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$MaximumContrastImplToJson(
      this,
    );
  }
}

abstract class MaximumContrast implements ContrastLevel {
  const factory MaximumContrast() = _$MaximumContrastImpl;

  factory MaximumContrast.fromJson(Map<String, dynamic> json) =
      _$MaximumContrastImpl.fromJson;
}

SizeClass _$SizeClassFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'compact':
      return CompactSize.fromJson(json);
    case 'regular':
      return RegularSize.fromJson(json);
    case 'large':
      return LargeSize.fromJson(json);
    case 'extraLarge':
      return ExtraLargeSize.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'SizeClass',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$SizeClass {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() compact,
    required TResult Function() regular,
    required TResult Function() large,
    required TResult Function() extraLarge,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? compact,
    TResult? Function()? regular,
    TResult? Function()? large,
    TResult? Function()? extraLarge,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? compact,
    TResult Function()? regular,
    TResult Function()? large,
    TResult Function()? extraLarge,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CompactSize value) compact,
    required TResult Function(RegularSize value) regular,
    required TResult Function(LargeSize value) large,
    required TResult Function(ExtraLargeSize value) extraLarge,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CompactSize value)? compact,
    TResult? Function(RegularSize value)? regular,
    TResult? Function(LargeSize value)? large,
    TResult? Function(ExtraLargeSize value)? extraLarge,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CompactSize value)? compact,
    TResult Function(RegularSize value)? regular,
    TResult Function(LargeSize value)? large,
    TResult Function(ExtraLargeSize value)? extraLarge,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  /// Serializes this SizeClass to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SizeClassCopyWith<$Res> {
  factory $SizeClassCopyWith(SizeClass value, $Res Function(SizeClass) then) =
      _$SizeClassCopyWithImpl<$Res, SizeClass>;
}

/// @nodoc
class _$SizeClassCopyWithImpl<$Res, $Val extends SizeClass>
    implements $SizeClassCopyWith<$Res> {
  _$SizeClassCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SizeClass
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$CompactSizeImplCopyWith<$Res> {
  factory _$$CompactSizeImplCopyWith(
          _$CompactSizeImpl value, $Res Function(_$CompactSizeImpl) then) =
      __$$CompactSizeImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CompactSizeImplCopyWithImpl<$Res>
    extends _$SizeClassCopyWithImpl<$Res, _$CompactSizeImpl>
    implements _$$CompactSizeImplCopyWith<$Res> {
  __$$CompactSizeImplCopyWithImpl(
      _$CompactSizeImpl _value, $Res Function(_$CompactSizeImpl) _then)
      : super(_value, _then);

  /// Create a copy of SizeClass
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
@JsonSerializable()
class _$CompactSizeImpl implements CompactSize {
  const _$CompactSizeImpl({final String? $type}) : $type = $type ?? 'compact';

  factory _$CompactSizeImpl.fromJson(Map<String, dynamic> json) =>
      _$$CompactSizeImplFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'SizeClass.compact()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$CompactSizeImpl);
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() compact,
    required TResult Function() regular,
    required TResult Function() large,
    required TResult Function() extraLarge,
  }) {
    return compact();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? compact,
    TResult? Function()? regular,
    TResult? Function()? large,
    TResult? Function()? extraLarge,
  }) {
    return compact?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? compact,
    TResult Function()? regular,
    TResult Function()? large,
    TResult Function()? extraLarge,
    required TResult orElse(),
  }) {
    if (compact != null) {
      return compact();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CompactSize value) compact,
    required TResult Function(RegularSize value) regular,
    required TResult Function(LargeSize value) large,
    required TResult Function(ExtraLargeSize value) extraLarge,
  }) {
    return compact(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CompactSize value)? compact,
    TResult? Function(RegularSize value)? regular,
    TResult? Function(LargeSize value)? large,
    TResult? Function(ExtraLargeSize value)? extraLarge,
  }) {
    return compact?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CompactSize value)? compact,
    TResult Function(RegularSize value)? regular,
    TResult Function(LargeSize value)? large,
    TResult Function(ExtraLargeSize value)? extraLarge,
    required TResult orElse(),
  }) {
    if (compact != null) {
      return compact(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CompactSizeImplToJson(
      this,
    );
  }
}

abstract class CompactSize implements SizeClass {
  const factory CompactSize() = _$CompactSizeImpl;

  factory CompactSize.fromJson(Map<String, dynamic> json) =
      _$CompactSizeImpl.fromJson;
}

/// @nodoc
abstract class _$$RegularSizeImplCopyWith<$Res> {
  factory _$$RegularSizeImplCopyWith(
          _$RegularSizeImpl value, $Res Function(_$RegularSizeImpl) then) =
      __$$RegularSizeImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$RegularSizeImplCopyWithImpl<$Res>
    extends _$SizeClassCopyWithImpl<$Res, _$RegularSizeImpl>
    implements _$$RegularSizeImplCopyWith<$Res> {
  __$$RegularSizeImplCopyWithImpl(
      _$RegularSizeImpl _value, $Res Function(_$RegularSizeImpl) _then)
      : super(_value, _then);

  /// Create a copy of SizeClass
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
@JsonSerializable()
class _$RegularSizeImpl implements RegularSize {
  const _$RegularSizeImpl({final String? $type}) : $type = $type ?? 'regular';

  factory _$RegularSizeImpl.fromJson(Map<String, dynamic> json) =>
      _$$RegularSizeImplFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'SizeClass.regular()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$RegularSizeImpl);
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() compact,
    required TResult Function() regular,
    required TResult Function() large,
    required TResult Function() extraLarge,
  }) {
    return regular();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? compact,
    TResult? Function()? regular,
    TResult? Function()? large,
    TResult? Function()? extraLarge,
  }) {
    return regular?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? compact,
    TResult Function()? regular,
    TResult Function()? large,
    TResult Function()? extraLarge,
    required TResult orElse(),
  }) {
    if (regular != null) {
      return regular();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CompactSize value) compact,
    required TResult Function(RegularSize value) regular,
    required TResult Function(LargeSize value) large,
    required TResult Function(ExtraLargeSize value) extraLarge,
  }) {
    return regular(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CompactSize value)? compact,
    TResult? Function(RegularSize value)? regular,
    TResult? Function(LargeSize value)? large,
    TResult? Function(ExtraLargeSize value)? extraLarge,
  }) {
    return regular?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CompactSize value)? compact,
    TResult Function(RegularSize value)? regular,
    TResult Function(LargeSize value)? large,
    TResult Function(ExtraLargeSize value)? extraLarge,
    required TResult orElse(),
  }) {
    if (regular != null) {
      return regular(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$RegularSizeImplToJson(
      this,
    );
  }
}

abstract class RegularSize implements SizeClass {
  const factory RegularSize() = _$RegularSizeImpl;

  factory RegularSize.fromJson(Map<String, dynamic> json) =
      _$RegularSizeImpl.fromJson;
}

/// @nodoc
abstract class _$$LargeSizeImplCopyWith<$Res> {
  factory _$$LargeSizeImplCopyWith(
          _$LargeSizeImpl value, $Res Function(_$LargeSizeImpl) then) =
      __$$LargeSizeImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LargeSizeImplCopyWithImpl<$Res>
    extends _$SizeClassCopyWithImpl<$Res, _$LargeSizeImpl>
    implements _$$LargeSizeImplCopyWith<$Res> {
  __$$LargeSizeImplCopyWithImpl(
      _$LargeSizeImpl _value, $Res Function(_$LargeSizeImpl) _then)
      : super(_value, _then);

  /// Create a copy of SizeClass
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
@JsonSerializable()
class _$LargeSizeImpl implements LargeSize {
  const _$LargeSizeImpl({final String? $type}) : $type = $type ?? 'large';

  factory _$LargeSizeImpl.fromJson(Map<String, dynamic> json) =>
      _$$LargeSizeImplFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'SizeClass.large()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LargeSizeImpl);
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() compact,
    required TResult Function() regular,
    required TResult Function() large,
    required TResult Function() extraLarge,
  }) {
    return large();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? compact,
    TResult? Function()? regular,
    TResult? Function()? large,
    TResult? Function()? extraLarge,
  }) {
    return large?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? compact,
    TResult Function()? regular,
    TResult Function()? large,
    TResult Function()? extraLarge,
    required TResult orElse(),
  }) {
    if (large != null) {
      return large();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CompactSize value) compact,
    required TResult Function(RegularSize value) regular,
    required TResult Function(LargeSize value) large,
    required TResult Function(ExtraLargeSize value) extraLarge,
  }) {
    return large(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CompactSize value)? compact,
    TResult? Function(RegularSize value)? regular,
    TResult? Function(LargeSize value)? large,
    TResult? Function(ExtraLargeSize value)? extraLarge,
  }) {
    return large?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CompactSize value)? compact,
    TResult Function(RegularSize value)? regular,
    TResult Function(LargeSize value)? large,
    TResult Function(ExtraLargeSize value)? extraLarge,
    required TResult orElse(),
  }) {
    if (large != null) {
      return large(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$LargeSizeImplToJson(
      this,
    );
  }
}

abstract class LargeSize implements SizeClass {
  const factory LargeSize() = _$LargeSizeImpl;

  factory LargeSize.fromJson(Map<String, dynamic> json) =
      _$LargeSizeImpl.fromJson;
}

/// @nodoc
abstract class _$$ExtraLargeSizeImplCopyWith<$Res> {
  factory _$$ExtraLargeSizeImplCopyWith(_$ExtraLargeSizeImpl value,
          $Res Function(_$ExtraLargeSizeImpl) then) =
      __$$ExtraLargeSizeImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ExtraLargeSizeImplCopyWithImpl<$Res>
    extends _$SizeClassCopyWithImpl<$Res, _$ExtraLargeSizeImpl>
    implements _$$ExtraLargeSizeImplCopyWith<$Res> {
  __$$ExtraLargeSizeImplCopyWithImpl(
      _$ExtraLargeSizeImpl _value, $Res Function(_$ExtraLargeSizeImpl) _then)
      : super(_value, _then);

  /// Create a copy of SizeClass
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
@JsonSerializable()
class _$ExtraLargeSizeImpl implements ExtraLargeSize {
  const _$ExtraLargeSizeImpl({final String? $type})
      : $type = $type ?? 'extraLarge';

  factory _$ExtraLargeSizeImpl.fromJson(Map<String, dynamic> json) =>
      _$$ExtraLargeSizeImplFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'SizeClass.extraLarge()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ExtraLargeSizeImpl);
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() compact,
    required TResult Function() regular,
    required TResult Function() large,
    required TResult Function() extraLarge,
  }) {
    return extraLarge();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? compact,
    TResult? Function()? regular,
    TResult? Function()? large,
    TResult? Function()? extraLarge,
  }) {
    return extraLarge?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? compact,
    TResult Function()? regular,
    TResult Function()? large,
    TResult Function()? extraLarge,
    required TResult orElse(),
  }) {
    if (extraLarge != null) {
      return extraLarge();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CompactSize value) compact,
    required TResult Function(RegularSize value) regular,
    required TResult Function(LargeSize value) large,
    required TResult Function(ExtraLargeSize value) extraLarge,
  }) {
    return extraLarge(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CompactSize value)? compact,
    TResult? Function(RegularSize value)? regular,
    TResult? Function(LargeSize value)? large,
    TResult? Function(ExtraLargeSize value)? extraLarge,
  }) {
    return extraLarge?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CompactSize value)? compact,
    TResult Function(RegularSize value)? regular,
    TResult Function(LargeSize value)? large,
    TResult Function(ExtraLargeSize value)? extraLarge,
    required TResult orElse(),
  }) {
    if (extraLarge != null) {
      return extraLarge(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ExtraLargeSizeImplToJson(
      this,
    );
  }
}

abstract class ExtraLargeSize implements SizeClass {
  const factory ExtraLargeSize() = _$ExtraLargeSizeImpl;

  factory ExtraLargeSize.fromJson(Map<String, dynamic> json) =
      _$ExtraLargeSizeImpl.fromJson;
}
