// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'voice_language.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

VoiceLanguage _$VoiceLanguageFromJson(Map<String, dynamic> json) {
  return _VoiceLanguage.fromJson(json);
}

/// @nodoc
mixin _$VoiceLanguage {
  String get code => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  String get nativeName => throw _privateConstructorUsedError;
  bool get isSTTSupported => throw _privateConstructorUsedError;
  bool get isTTSSupported => throw _privateConstructorUsedError;
  String get sttCode => throw _privateConstructorUsedError;
  String get ttsCode => throw _privateConstructorUsedError;
  double get defaultSpeechRate => throw _privateConstructorUsedError;
  double get defaultVolume => throw _privateConstructorUsedError;
  double get defaultPitch => throw _privateConstructorUsedError;

  /// Serializes this VoiceLanguage to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of VoiceLanguage
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $VoiceLanguageCopyWith<VoiceLanguage> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VoiceLanguageCopyWith<$Res> {
  factory $VoiceLanguageCopyWith(
          VoiceLanguage value, $Res Function(VoiceLanguage) then) =
      _$VoiceLanguageCopyWithImpl<$Res, VoiceLanguage>;
  @useResult
  $Res call(
      {String code,
      String name,
      String nativeName,
      bool isSTTSupported,
      bool isTTSSupported,
      String sttCode,
      String ttsCode,
      double defaultSpeechRate,
      double defaultVolume,
      double defaultPitch});
}

/// @nodoc
class _$VoiceLanguageCopyWithImpl<$Res, $Val extends VoiceLanguage>
    implements $VoiceLanguageCopyWith<$Res> {
  _$VoiceLanguageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of VoiceLanguage
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = null,
    Object? name = null,
    Object? nativeName = null,
    Object? isSTTSupported = null,
    Object? isTTSSupported = null,
    Object? sttCode = null,
    Object? ttsCode = null,
    Object? defaultSpeechRate = null,
    Object? defaultVolume = null,
    Object? defaultPitch = null,
  }) {
    return _then(_value.copyWith(
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      nativeName: null == nativeName
          ? _value.nativeName
          : nativeName // ignore: cast_nullable_to_non_nullable
              as String,
      isSTTSupported: null == isSTTSupported
          ? _value.isSTTSupported
          : isSTTSupported // ignore: cast_nullable_to_non_nullable
              as bool,
      isTTSSupported: null == isTTSSupported
          ? _value.isTTSSupported
          : isTTSSupported // ignore: cast_nullable_to_non_nullable
              as bool,
      sttCode: null == sttCode
          ? _value.sttCode
          : sttCode // ignore: cast_nullable_to_non_nullable
              as String,
      ttsCode: null == ttsCode
          ? _value.ttsCode
          : ttsCode // ignore: cast_nullable_to_non_nullable
              as String,
      defaultSpeechRate: null == defaultSpeechRate
          ? _value.defaultSpeechRate
          : defaultSpeechRate // ignore: cast_nullable_to_non_nullable
              as double,
      defaultVolume: null == defaultVolume
          ? _value.defaultVolume
          : defaultVolume // ignore: cast_nullable_to_non_nullable
              as double,
      defaultPitch: null == defaultPitch
          ? _value.defaultPitch
          : defaultPitch // ignore: cast_nullable_to_non_nullable
              as double,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$VoiceLanguageImplCopyWith<$Res>
    implements $VoiceLanguageCopyWith<$Res> {
  factory _$$VoiceLanguageImplCopyWith(
          _$VoiceLanguageImpl value, $Res Function(_$VoiceLanguageImpl) then) =
      __$$VoiceLanguageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String code,
      String name,
      String nativeName,
      bool isSTTSupported,
      bool isTTSSupported,
      String sttCode,
      String ttsCode,
      double defaultSpeechRate,
      double defaultVolume,
      double defaultPitch});
}

/// @nodoc
class __$$VoiceLanguageImplCopyWithImpl<$Res>
    extends _$VoiceLanguageCopyWithImpl<$Res, _$VoiceLanguageImpl>
    implements _$$VoiceLanguageImplCopyWith<$Res> {
  __$$VoiceLanguageImplCopyWithImpl(
      _$VoiceLanguageImpl _value, $Res Function(_$VoiceLanguageImpl) _then)
      : super(_value, _then);

  /// Create a copy of VoiceLanguage
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = null,
    Object? name = null,
    Object? nativeName = null,
    Object? isSTTSupported = null,
    Object? isTTSSupported = null,
    Object? sttCode = null,
    Object? ttsCode = null,
    Object? defaultSpeechRate = null,
    Object? defaultVolume = null,
    Object? defaultPitch = null,
  }) {
    return _then(_$VoiceLanguageImpl(
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      nativeName: null == nativeName
          ? _value.nativeName
          : nativeName // ignore: cast_nullable_to_non_nullable
              as String,
      isSTTSupported: null == isSTTSupported
          ? _value.isSTTSupported
          : isSTTSupported // ignore: cast_nullable_to_non_nullable
              as bool,
      isTTSSupported: null == isTTSSupported
          ? _value.isTTSSupported
          : isTTSSupported // ignore: cast_nullable_to_non_nullable
              as bool,
      sttCode: null == sttCode
          ? _value.sttCode
          : sttCode // ignore: cast_nullable_to_non_nullable
              as String,
      ttsCode: null == ttsCode
          ? _value.ttsCode
          : ttsCode // ignore: cast_nullable_to_non_nullable
              as String,
      defaultSpeechRate: null == defaultSpeechRate
          ? _value.defaultSpeechRate
          : defaultSpeechRate // ignore: cast_nullable_to_non_nullable
              as double,
      defaultVolume: null == defaultVolume
          ? _value.defaultVolume
          : defaultVolume // ignore: cast_nullable_to_non_nullable
              as double,
      defaultPitch: null == defaultPitch
          ? _value.defaultPitch
          : defaultPitch // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$VoiceLanguageImpl implements _VoiceLanguage {
  const _$VoiceLanguageImpl(
      {required this.code,
      required this.name,
      required this.nativeName,
      this.isSTTSupported = true,
      this.isTTSSupported = true,
      required this.sttCode,
      required this.ttsCode,
      this.defaultSpeechRate = 1.0,
      this.defaultVolume = 1.0,
      this.defaultPitch = 1.0});

  factory _$VoiceLanguageImpl.fromJson(Map<String, dynamic> json) =>
      _$$VoiceLanguageImplFromJson(json);

  @override
  final String code;
  @override
  final String name;
  @override
  final String nativeName;
  @override
  @JsonKey()
  final bool isSTTSupported;
  @override
  @JsonKey()
  final bool isTTSSupported;
  @override
  final String sttCode;
  @override
  final String ttsCode;
  @override
  @JsonKey()
  final double defaultSpeechRate;
  @override
  @JsonKey()
  final double defaultVolume;
  @override
  @JsonKey()
  final double defaultPitch;

  @override
  String toString() {
    return 'VoiceLanguage(code: $code, name: $name, nativeName: $nativeName, isSTTSupported: $isSTTSupported, isTTSSupported: $isTTSSupported, sttCode: $sttCode, ttsCode: $ttsCode, defaultSpeechRate: $defaultSpeechRate, defaultVolume: $defaultVolume, defaultPitch: $defaultPitch)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$VoiceLanguageImpl &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.nativeName, nativeName) ||
                other.nativeName == nativeName) &&
            (identical(other.isSTTSupported, isSTTSupported) ||
                other.isSTTSupported == isSTTSupported) &&
            (identical(other.isTTSSupported, isTTSSupported) ||
                other.isTTSSupported == isTTSSupported) &&
            (identical(other.sttCode, sttCode) || other.sttCode == sttCode) &&
            (identical(other.ttsCode, ttsCode) || other.ttsCode == ttsCode) &&
            (identical(other.defaultSpeechRate, defaultSpeechRate) ||
                other.defaultSpeechRate == defaultSpeechRate) &&
            (identical(other.defaultVolume, defaultVolume) ||
                other.defaultVolume == defaultVolume) &&
            (identical(other.defaultPitch, defaultPitch) ||
                other.defaultPitch == defaultPitch));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      code,
      name,
      nativeName,
      isSTTSupported,
      isTTSSupported,
      sttCode,
      ttsCode,
      defaultSpeechRate,
      defaultVolume,
      defaultPitch);

  /// Create a copy of VoiceLanguage
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$VoiceLanguageImplCopyWith<_$VoiceLanguageImpl> get copyWith =>
      __$$VoiceLanguageImplCopyWithImpl<_$VoiceLanguageImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$VoiceLanguageImplToJson(
      this,
    );
  }
}

abstract class _VoiceLanguage implements VoiceLanguage {
  const factory _VoiceLanguage(
      {required final String code,
      required final String name,
      required final String nativeName,
      final bool isSTTSupported,
      final bool isTTSSupported,
      required final String sttCode,
      required final String ttsCode,
      final double defaultSpeechRate,
      final double defaultVolume,
      final double defaultPitch}) = _$VoiceLanguageImpl;

  factory _VoiceLanguage.fromJson(Map<String, dynamic> json) =
      _$VoiceLanguageImpl.fromJson;

  @override
  String get code;
  @override
  String get name;
  @override
  String get nativeName;
  @override
  bool get isSTTSupported;
  @override
  bool get isTTSSupported;
  @override
  String get sttCode;
  @override
  String get ttsCode;
  @override
  double get defaultSpeechRate;
  @override
  double get defaultVolume;
  @override
  double get defaultPitch;

  /// Create a copy of VoiceLanguage
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$VoiceLanguageImplCopyWith<_$VoiceLanguageImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
